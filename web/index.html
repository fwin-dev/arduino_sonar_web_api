<!DOCTYPE html>
<meta charset="utf-8">
<style>

rect {
	fill: none;
	pointer-events: all;
}

.node {
	fill: #000;
}

.textDist, .textId {
	font: 10px sans-serif;
	pointer-events: none;
}

.textId {
	text-anchor: end;
}

.textDist {
	text-anchor: start;
	fill: red;
}

.textDist, .textId {
	text-transform: uppercase;
	font-weight: bold;
}

.cursor {
	fill: none;
	stroke: brown;
	pointer-events: none;
}

.link {
	stroke: #D7D7D7;
	stroke-width: 2px;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script>
	
	var width = 960,
    height = 500,
    r = 500;

    var mLinkNum = {};

	var fill = d3.scale.category20();

	var force = d3.layout.force()
	    .size([width, height])
	    .nodes([{}]) // initialize with a single node
	    //.linkDistance(function(l){
	    //	return Math.round(l.source.dist * 1.5);
	    //})
		.linkDistance(150)
	    .gravity(0.15)
	    .friction(0.6)
	    .charge(function(n){
	    	var r = randomNumberBetween(3000, 4000) * -1;
	    	return r;
	    })
	    .on("tick", tick);

	var svg = d3.select("body").append("svg") 
		.attr("viewBox", "0 0 " + width + " " + height)
		.attr("preserveAspectRatio", "xMinYMin meet")
		.attr("transform", "translate(" + r + "," + r +") rotate(180) scale(-1, -1)");

	svg.append("rect")
	    .attr("width", width)
	    .attr("height", height);

	var nodes = force.nodes(),
	    links = force.links(),
	    node = svg.selectAll(".node"),
	    link = svg.selectAll(".link");


	restart();

	function processSonar(sonarData) {
		var found = false;

		// If sonar "hears" another "id" then link it with that "id"
		if(sonarData.hears){
			// Get "hears" id
			var target = null, source = null;
			for(var i = 0; i < nodes.length; i++){
				if(nodes[i].id == sonarData.hears){
					target = nodes[i];
				}
				if(nodes[i].id == sonarData.id){
					source = nodes[i];
				}
			}

			if(target != null && source != null){

				//if(!source.hears){
				//	source.hears = [];
				//}

				//source.hears.push(target.id);
				links.push({source: source, target: target});

				//if(target.hears){
				//	if(target.hears.indexOf(source.id) > -1){
				//		links.pop();
				//	}
				//}

				// update hears list
				/*if(target.hears){
					if(target.hears.indexOf(source.id) > -1){
						links.push({source: source, target: target});
					}
				}else{
					if(source.hears){
						if(source.hears.indexOf(target.id) > -1){
							links.push({source: source, target: target});
						}
					}else{
						if(!source.hears){
							source.hears = [];
						}

						source.hears.push(target.id);
					}
				}*/
			}
		}
		// if sonar has "dist" then link it with the primary node
		if(sonarData.dist){
			var textNodes = svg.selectAll(".textNode");

			// If node exists, update it...
			for(var i = 0; i < nodes.length; i++){
				if(nodes[i].id == sonarData.id){
					// Update text
					svg.select("#" + nodes[i].id)
						.text(nodes[i].dist)
						.transition()
					    .duration(1000)
						.tween("text", function(d) {
							var i = d3.interpolate(this.textContent, sonarData.dist);
							return function(t) {
								this.textContent = Math.round(i(t));
							}
						});
					
					// update old value
					nodes[i].dist = sonarData.dist;

					//textNodes[0][i-1].innerHTML = sonarData.dist;

					found = true;
					break;
				}
			}

			if(!found){
				// Get master node
				var masterNode = nodes[0];

				// Master node x,y
				var x = masterNode.x,
					y = masterNode.y;

				// New dist
				var x2 = sonarData.dist * x,
					y2 = sonarData.dist * y;
				var dist = Math.sqrt(x2 + y2);

				// else add new
				var node = {x: Math.round(x + (Math.random() * 2)), y: Math.round(y + (Math.random() * 2)), dist: sonarData.dist, id: sonarData.id};
				nodes.push(node);
				links.push({source: node, target: masterNode});
			}
			
		}

		restart();
	}

	function tick() {
		
		link.attr("x1", function(d) { return d.source.x; })
			.attr("y1", function(d) { return d.source.y; })
			.attr("x2", function(d) { return d.target.x; })
			.attr("y2", function(d) { return d.target.y; })
		

		/*link.attr("d", function(d) {
            var dx = d.target.x - d.source.x,
                dy = d.target.y - d.source.y,
                dr = Math.sqrt(dx * dx + dy * dy);
            // get the total link numbers between source and target node
            var lTotalLinkNum = mLinkNum[d.source.id + "," + d.target.id] || mLinkNum[d.target.id + "," + d.source.id];
            if(lTotalLinkNum > 1)
            {
                // if there are multiple links between these two nodes, we need generate different dr for each path
                dr = dr/(1 + (1/lTotalLinkNum) * (d.linkindex - 1));
            }	    
            // generate svg path
            return "M" + d.source.x + "," + d.source.y + 
                "A" + dr + "," + dr + " 0 0 1," + d.target.x + "," + d.target.y + 
                "A" + dr + "," + dr + " 0 0 0," + d.source.x + "," + d.source.y;	
        });*/

		node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
	}

	function restart() {
		//sortLinks();

		//setLinkIndexAndNum();

		link = link.data(links);

		link.enter().insert("line", ".node")
			.attr("class", "link")
			.attr("stroke-dasharray", function(d){
				if(d.target.id !== undefined){
					console.log(d);
					// does the target.id already have a link to this source.id
					for (var i = 0; i < links.length; i++) {
						if(links[i].source.id == d.target.id && links[i].target.id == d.source.id){
							// the target.id has a link already
							return "5, 1";
						}
					};
				}
				return "5, 10";
			});

		node = node.data(nodes);

		if(nodes.length == 1){
			node.enter().insert("circle", ".cursor")
				.attr("class", "node")
				.attr("r", 12)
				.call(force.drag);
		}else{

			var nodeEnter = node.enter().append("g")
				.attr("class", "node")
				.call(force.drag);

			nodeEnter.append("circle", ".cursor")
				.attr("fill", getRandomColor())
				.attr("r", 5);

			nodeEnter.append("text")
				.attr("class", "textId")
				.attr("dy", "1.4em")
				.text(function(d) { return d.id + " - "; });

			nodeEnter.append("text")
				.attr("class", "textDist")
				.attr("id", function(d){ return d.id; })
				.attr("dy", "1.4em")
				.attr("dx", ".2em")
				.text(0)
				.transition()
			    .duration(1000)
				.tween("text", function(d) {
					var i = d3.interpolate(this.textContent, d.dist);
					return function(t) {
						this.textContent = Math.round(i(t));
					}
				});
		}

		force.start();
	}

	var socket = io('http://localhost');
	
	socket.on('old sonar', function (data) {
		for(var prop in data){
			if(data.hasOwnProperty(prop)) {
				var sonarData = {};
				sonarData.id = prop;

				if(data[prop].dist){
					sonarData.dist = data[prop].dist;
				}

				processSonar(sonarData);
			}
		}

		// Had to load all the nodes before running "hears"
		for(var prop in data){
			if(data.hasOwnProperty(prop)) {
				var sonarData = {};
				sonarData.id = prop;

				if(data[prop].hears){
					sonarData.hears = data[prop].hears;
				}

				processSonar(sonarData);
			}
		}
	});
	socket.on('new sonar', function (data){
		processSonar(data);
	});

	function getRandomColor() {
	    var letters = '0123456789ABCDEF'.split('');
	    var color = '#';
	    for (var i = 0; i < 6; i++ ) {
	        color += letters[Math.floor(Math.random() * 16)];
	    }
	    return color;
	}

	function randomNumberBetween(min, max){
		return Math.floor(Math.random() * max) + min;
	}

</script>
</body>
</html>